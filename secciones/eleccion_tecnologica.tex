\section{Elección tecnológica}

\subsection{Desarrollo móvil}

Uno de los requisitos que se contemplan en el proyecto especifica que la aplicación debe estar desarrollada tanto para Android como para IOS (\ref{rnf-plataformas}). Esto será una de las mayores condiciones a tener en cuenta a la hora de elegir las herramientas a utilizar para el desarrollo de la aplicación móvil. Actualmente para el desarrollo de aplicaciones móviles existen dos alternativas: las aplicaciones nativas y las aplicaciones denominadas como \textit{cross-platform}.

Las aplicaciones nativas, son las desarrolladas con las herramientas proporcionadas por las diferentes plataformas. Para Android tenemos Android SDK \cite{android-sdk}, la cual permite desarrollar aplicaciones tanto Android con Java, Klotin y C++. Para dispositivos de Apple tenemos IOS SDK \cite{ios-sdk}, que nos permiten desarrollar en Objective-C y Swift. 

Por otro lado, las aplicaciones \textit{cross-platform} son ``aplicaciones que bajo un mismo desarrollo pueden funcionar en múltiples plataformas'' \cite{cross-platform-comparacion}. Dentro de este grupo se incluyen tanto aplicaciones web cargadas desde un motor de renderizado web, como aplicaciones que bajo el mismo código son convertidas en nativas para ambas plataformas por igual. 

En los últimos años han aparecido varias herramientas \textit{cross-platform}, cambiando el paradigma de desarrollo de aplicaciones móviles. El principal beneficio de estas tecnologías es la reducción del tiempo de desarrollo, así como los costes. En este caso, el tiempo de desarrollo es vital. El tener un solo desarrollo en lugar de dos proyectos paralelos para la aplicación proporcionará una mayor fluidez al proyecto, así como una mayor unificación de la experiencia de usuario en ambas plataformas. A su vez escoger esta alternativa proporcionará un más fácil mantenimiento posterior de la propia aplicación. 

En el artículo \cite{cross-platform-comparacion} se estudian las diferencias de rendimiento que existen entre aplicaciones desarrolladas de forma nativa con las desarrolladas con populares frameworks \textit{cross-platforms}. El estudio nos muestra que según los usos, el uso de recursos puede ser un poco mayor para aplicaciones desarrolladas con estas herramientas. Aun con esto, la diferencia de rendimiento es asumible, ya que en este caso la aplicación no necesitará del uso de herramientas nativas del sistema que lacren el rendimiento. La mayoría de frameworks actuales nos permiten desarrollar aplicaciones que ofrecen una experiencia de usuario fluida y muy cercana a la de aplicaciones nativas.

Existen muchas herramientas actuales para desarrollar aplicaciones \textit{cross-platforms}. Según una encuesta realizada por JetBrains a diferentes desarrolladores \cite{jetbrains-survey}, el desarrollo de aplicaciones multiplataforma está liderado por dos alternativas, \textit{React-native} y \textit{Flutter}. Desarrolladas por Facebook y Google, ambas son utilizadas en infinidad de aplicaciones como son Airbnb o Discord en el primer caso o The New York Times o Ebay en el segundo. Ambas alternativas serían totalmente válidas para el desarrollo de esta aplicación.

Entre ambas la mejor elección en este caso será React-Native. Principalmente, el conocimiento previo y experiencia con JavaScript facilitará el proceso de desarrollo y reducirá el tiempo de formación en el uso de la herramienta. Además, durante alguna de las reuniones con los clientes, estos especificaron que en un futuro les gustaría que la aplicación se adaptase a una web para poder trabajar desde diferentes dispositivos. El que React-Native tenga su tecnología ``hermana'' para la web, \textit{React}, permitirá que en un futuro, la adaptación a una aplicación web, sea bastante más sencilla debido a la reutilización de la mayoría del código. 

\subsection{Base de datos}

Últimamente se han popularizado muchas alternativas a las base de datos relacionales. La mayoría de ellas se engloban en el grupo popularmente conocido como NoSQL. Son agrupadas de esta forma debido a que muchas de ellas comparten diferencias con las relacionales. 

Ambos tipos de bases de datos tienen ciertas ventajas e inconvenientes. En la mayoría de los casos estas diferencias vienen dadas por como están estructurados los datos y las propiedades que estas garantizan.

Una de las propiedades clave en nuestro caso será la validez de los datos introducidos. Es clave que al introducir datos estos se inserten sin errores y no dejen a esta en un estado inválido. Necesitamos que la alternativa escogida respete las propiedades ACID. Esta es una de las principales ``desventajas'' de las alternativas NoSQL.  ``Normalmente estas no soportan las transiciones ACID porporcionadas por las bases de datos relacionales'' \cite{NoSQLvsSQL_1}. Esto nos da una primera pista de que muchas de estas alternativas pueden no ser válidas en este proyecto.

Para tomar la decisión final será necesario analizar algunas de las alternativas NoSQL más utilizadas en estos ámbitos. Las bases de datos \textbf{key-value} son una de ellas. Básicamente siguen una estructura en la que los datos están asociados a una clave única. Estas permiten accesos e inserciones rápidas y ofrecen una mayor flexibilidad en los datos a almacenar. Por otra parte la estructura es muy simple y carece de relaciones, algo fundamental en nuestro caso, lo que nos lleva a descartar esta opción.

A partir de esta alternativa surgen las bases de datos \textbf{basadas en documentos}. Estas tienen la misma estructura que las \textit{key-value}, con la diferencia de que utilizan metadatos asociados a los documentos y permiten obtener estos, no solo en base a su clave única, si no también en base a su contenido. Estas proporcionan una mayor flexibilidad que las relacionales, permitiendo que los documentos no tengan que seguir una estructura fija como ocurre con las tablas en las relacionales. En este caso, no necesitamos esta flexibilidad ya que los datos a almacenar han sido claramente predefinidos con el cliente. Por otra parte, ``las bases de datos orientadas a documentos deben ser evitadas si la base de datos requiere de muchas relaciones'' \cite{NoSQLvsSQL_2}, lo que en nuestro caso hará que nos decantemos de nuevo por las relacionales.

Otras bases de datos NoSQL muy utilizadas, son las bases de datos basadas en grafos. Estas ponen el foco en las relaciones aunque internamente estén implementadas bajo alternativas anteriormente mencionadas. En nuestro caso, no tiene sentido modelar la información bajo un grafo ya que las relaciones, aun siendo importantes, no tienen el foco principal, sobretodo a la hora de acceder a la información.

Hay bastante más alternativas NoSQL, pero en su mayoría tienen como foco el BigData o la ingeniería de datos, por lo que no nos serán interesantes aquí. Una base de datos relacional nos proporcionará la robustez y funcionalidades necesarias en este caso, siendo la mejor alternativa a utilizar.

\subsection{Desarrollo backend}

Para el desarrollo de backend existe múltiples alternativas. Existen varias tecnologías y frameworks que nos permitirán aplicar la arquitectura diseñada. Múltiples frameworks nos serían útiles para realizar una API que nos permitiese hacer de vista en nuestro sistema. Algunos ejemplos son Flask con Python, Laravel para PHP o Express para Node.JS. 

En este caso, no necesitamos implementar funcionalidades que nos liguen a una tecnología concreta, lo que no da más flexibilidad a la hora de elegir. Nos interesa decidir una herramienta que facilite el desarrollo y lo agilice. Para esto lo más sensato es basarse en el nivel del desarrollador en cada una de ellas. En general, los conocimientos en Javascript son mayores que en cualquier otro lenguaje.

Analizando aspectos más técnicos, en \cite{Crawford2017ACO} hacen una comparación exhaustiva de las diferentes tecnologías más populares de backend, analizando desde la popularidad de estas, hasta el rendimiento que ofrecen. Estos resultados se ven reflejados en La tabla \ref{fig:comparison}.

\begin{table}[h!]
    \label{fig:comparison}
    \centering
    \begin{tabular}{|l|c|c|c|c|} 
    \hline
    \rowcolor[rgb]{0.949,0.949,0.949}                                                                                                                                                                             & \textbf{Node JS} & \textbf{PHP} & \textbf{Django} & \textbf{Rails}  \\ 
    \hline
    {\cellcolor[rgb]{0.949,0.949,0.949}}\begin{tabular}[c]{@{}>{\cellcolor[rgb]{0.949,0.949,0.949}}l@{}}\textbf{Getting}\\\textbf{started}\\\textbf{}\end{tabular}                                                & Very Good        & Excelent     & Very Good       & Good            \\ 
    \hline
    {\cellcolor[rgb]{0.949,0.949,0.949}}\begin{tabular}[c]{@{}>{\cellcolor[rgb]{0.949,0.949,0.949}}l@{}}\textbf{Help And }\\\textbf{Support}\\\textbf{}\end{tabular}                                              & Good             & Excelent     & Excelent        & Excelent        \\ 
    \hline
    {\cellcolor[rgb]{0.949,0.949,0.949}}\begin{tabular}[c]{@{}>{\cellcolor[rgb]{0.949,0.949,0.949}}l@{}}\textbf{Popularity}\\\textbf{}\end{tabular}                                                               & Very Good        & Excelent     & Fair            & Very Good       \\ 
    \hline
    {\cellcolor[rgb]{0.949,0.949,0.949}}\begin{tabular}[c]{@{}>{\cellcolor[rgb]{0.949,0.949,0.949}}l@{}}\textbf{Development }\\\textbf{tools and }\\\textbf{package}\\\textbf{management}\\\textbf{}\end{tabular} & Excelent         & Good         & Fair            & Very Good       \\ 
    \hline
    {\cellcolor[rgb]{0.949,0.949,0.949}}\begin{tabular}[c]{@{}>{\cellcolor[rgb]{0.949,0.949,0.949}}l@{}}\textbf{Environments}\\\textbf{}\end{tabular}                                                             & Excelent         & Poor         & Good            & Good            \\ 
    \hline
    {\cellcolor[rgb]{0.949,0.949,0.949}}\begin{tabular}[c]{@{}>{\cellcolor[rgb]{0.949,0.949,0.949}}l@{}}\textbf{Integration with }\\\textbf{databases}\\\textbf{}\end{tabular}                                    & Excelent         & Very Good    & Fair            & Very Good       \\ 
    \hline
    {\cellcolor[rgb]{0.949,0.949,0.949}}\begin{tabular}[c]{@{}>{\cellcolor[rgb]{0.949,0.949,0.949}}l@{}}\textbf{Performance}\\\textbf{}\end{tabular}                                                              & Excelent         & Fair         & Very Good       & Fair            \\
    \hline
    \end{tabular}
    \caption{Tabla de comparación de tecnologías obtenida de \protect\cite{Crawford2017ACO}}
\end{table}

El estudio nos resume en ciertos ámbitos la capacidad de algunas de las alternativas más populares. En nuestro caso, no es interesante absolutamente todo lo que refleja la tabla. Por ejemplo, al utilizar tecnologías de bases de datos altamente estandarizadas, cualquiera de las herramientas a utilizar nos ofrecerá una correcta integración con estas. Por otra parte, el rendimiento no será una prioridad. Es cierto que puede reducir costes a la fundación a la hora de alojar el servidor, pero no supondrá al no estar dirigida la aplicación a un alto número de usuarios no es algo que deba preocupar en exceso. 

En cuanto a los otros ámbitos, que sea una tecnología popular puede ayudar en un futuro a la asociación a buscar otros desarrolladores, para ampliar o adaptar la aplicación. Por otra parte, la ayuda y soporte, herramientas de desarrollo y ``environments'' tienen un mayor peso en la elección ya que pueden facilitar y agilizar el desarrollo. 

Teniendo en cuenta todo esto, creo que la mejor elección será Node.JS. Este facilitará en gran medida el desarrollo debido a que el desarrollo completo del sistema, tanto aplicación como backend, se haría con Javascript. Esto aumentará la compatibilidad e integración entre ambos servicios. Por otra parte al ser una herramienta popular, no será tan difícil encontrar desarrolladores para colaborar en futuros proyectos que puedan surgir. A todo esto se suma, que el conocimiento del equipo de desarrollo es mayor en esta tecnología, lo que reducirá el tiempo de aprendizaje, el cual sería mayor en incluso podría lastrar el proceso de desarrollo con otras tecnologías.
